import numpy as np
import gym
import os
from gym import spaces
import robosuite
from robosuite.controllers import load_controller_config
import imageio, tqdm
import copy
import cv2
from Environments.environment_specification import RawEnvironment
from collections import deque
import robosuite.utils.macros as macros
macros.SIMULATION_TIMESTEP = 0.02

# control_freq, num_obstacles, standard_reward, goal_reward, obstacle_reward, out_of_bounds_reward, 
# joint_mode, hard_obstacles, planar_mode
variants = {
    "no_obstacles": (2, 0, -0.1, 10, -3, -3, 0),
    "obstacles": (2, 10, -0.1, 10, -3, -3, 0),
    "obstacles_many": (2, 15, -0.1, 10, -3, -3, 0)
    "joint": (2, 15, -0.1, 10, -3, -3, 1)
    "hard": (2, 15, -1, 10, -3, -3, 2)
    "planar": (2, 15, -0.1, 10, -3, -3, 3)
}

DEFAULT = 0
JOINT_MODE = 1
PLANAR_MODE = 2

class RoboPushing(RawEnvironment):
    def __init__(self, variant="default", horizon=30, renderable=False):
        super().__init__()
        self.variant=variant
        control_freq, num_obstacles, standard_reward, goal_reward, obstacle_reward, out_of_bounds_reward, mode  = variants[variant]
        self.mode = mode
        self.goal_reward = goal_reward
        controller = "JOINT_POSITION" if self.mode==JOINT_MODE else "OSC_POSE" # TODO: handles only two action spaces at the moment
        self.env = robosuite.make(
                "Push",
                robots=["Panda"],
                controller_configs=load_controller_config(default_controller=controller),
                has_renderer=False,
                has_offscreen_renderer=renderable,
                render_visual_mesh=renderable,
                render_collision_mesh=False,
                camera_names=["frontview"] if renderable else None,
                control_freq=control_freq,
                horizon=horizon,
                use_object_obs=True,
                use_camera_obs=renderable,
                hard_reset = False,
                num_obstacles=num_obstacles,
                standard_reward=standard_reward, 
                goal_reward=goal_reward, 
                obstacle_reward=obstacle_reward, 
                out_of_bounds_reward=out_of_bounds_reward,
                hard_obstacles=hard_obstacles,
                keep_gripper_in_cube_plane=planar_mode
            )
        # environment properties
        self.num_actions = -1 # this must be defined, -1 for continuous. Only needed for primitive actions
        self.name = "RobosuitePushing" # required for an environment 
        self.discrete_actions = False
        self.frameskip = control_freq
        self.timeout_penalty = -horizon
        self.planar_mode = planar_mode 

        # spaces
        low, high = self.env.action_spec
        limit = 7 if self.mode == JOINT_MODE else 3
        self.action_shape = (limit,)
        self.action_space = spaces.Box(low=low[:limit], high=high[:limit])
        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=[9])
        self.renderable = renderable

        # running values
        self.timer = 0

        # state components
        self.reward = 0
        self.done = False
        self.action = np.zeros(self.action_shape)
        self.extracted_state = None

        # saving component
        self.save_module = save_module

        # factorized state properties
        self.object_names = [] # must be initialized, a list of names that controls the ordering of things
        self.object_sizes = dict() # must be initialized, a dictionary of name to length of the state
        self.object_range = dict() # the minimum and maximum values for a given feature of an object

        # obstacles and objects
        self.num_obstacles = num_obstacles
        self.objects = ["Action", "Gripper", "Block"] + ["Obstacle" + str(i) for i in range(num_obstacles)] + ["Target", "Reward", "Done"]

        self.full_state = self.reset()
        self.frame = self.full_state['raw_state'] # the image generated by the environment

    def set_named_state(self, obs_dict):
        obs_dict['Action'], obs_dict['Gripper'], obs_dict['Block'], obs_dict['Target'] = self.action, obs_dict['robot0_eef_pos'], obs_dict['cube_pos'], obs_dict['goal_pos']# assign the appropriate values
        for i in range(self.num_obstacles):
            obs_dict['Obstacle' + str(i)] = obs_dict[f"obstacle{i}_pos"]
        obs_dict['Reward'], obs_dict['Done'] = [self.reward], [self.done]

    def construct_full_state(self, factored_state, raw_state):
        self.full_state = {'raw_state': raw_state, 'factored_state': factored_state}
        return self.full_state

    def set_action(self, action):
        if self.mode == JOINT_MODE:
            use_act = action
        elif self.mode == PLANAR_MODE:
            use_act = np.concatenate([action[:2], [0,0,0,0]])
        else:
            use_act = np.concatenate([action, [0, 0, 0]])


    def step(self, action):
        # step internal robosuite environment
        self.action = action
        use_act = self.set_action(action)
        next_obs, self.reward, self.done, info = self.env.step(use_act)
        if self.reward == self.goal_reward: # don't wait at the goal, just terminate
            self.done = True
            info["TimeLimit.truncated"] = False
        else:
            info["TimeLimit.truncated"] = done

        # set state
        self.set_named_state(next_obs) # mutates next_obs
        img = next_obs["frontview_image"][::-1] if self.renderable else None
        obs = self.construct_full_state(next_obs, img)
        self.frame = self.full_state['raw_state']

        # step timers 
        self.itr += 1
        self.timer += 1

        # save module
        self.save_module.save(self.itr, full_state, info)

        if self.done:
            self.reset()
            self.timer = 0
        return obs, self.reward, self.done, info

    def get_state(self):
        return copy.deepcopy(self.full_state)

    def reset(self):
        obs = self.env.reset()
        self.set_named_state(obs)
        self.frame = obs["frontview_image"][::-1] if self.renderable else None
        return self.construct_full_state(obs, self.frame)

    def render(self):
        return self.frame

    def toString(self, extracted_state):
        estring = "ITR:" + str(self.itr) + "\t"
        for i, obj in enumerate(self.objects):
            if obj not in ["Reward", "Done"]:
                estring += obj + ":" + " ".join(map(str, extracted_state[obj])) + "\t" # TODO: attributes are limited to single floats
            else:
                estring += obj + ":" + str(int(extracted_state[obj][0])) + "\t"
        return estring

