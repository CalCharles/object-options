# Screen
import sys, cv2
import numpy as np
import imageio as imio
import os, copy
from Environment.environment import Environment
from Environment.Environments.Sokoban.sokoban_objects import *
from Environment.Environments.Sokoban.sokoban_specs import *
from Record.file_management import numpy_factored
from gym import spaces

class Sokoban(Environment):
    def __init__(self, frameskip = 1, variant=""):
        super(Sokoban, self).__init__()
        # breakout specialized parameters are stored in the variant
        self.variant = variant
        self.self_reset = True

        # environment properties
        self.num_actions = 4 # this must be defined, -1 for continuous. Only needed for primitive actions
        self.name = "Sokoban" # required for an environment 
        self.discrete_actions = True
        self.frameskip = 1 # no frameskip

        self.num_rows, self.num_columns, self.num_blocks, self.num_obstacles, self.num_targets, self.step_limit, self.preset = sokoban_variants[self.variant]

        # spaces
        self.action_shape = (1,)
        self.action_space = spaces.Discrete(self.num_actions) # gym.spaces
        self.observation_space = spaces.Box(low=0, high=255, shape=(RNG, RNG), dtype=np.uint8) # raw space, gym.spaces
        self.seed_counter = -1

        # state components
        self.frame = None # the image generated by the environment
        self.reward = 0
        self.done = False
        self.action = np.zeros(self.action_shape)
        self.extracted_state = None
        self.steps = 0

        # running values
        self.itr = 0
        self.total_score = 0

        # factorized state properties
        ranges, dynamics, position_masks, instanced = generate_specs(self.num_rows, self.num_columns, self.num_obstacles, self.num_blocks, self.num_targets)
        self.object_names = ["Action", "Pusher", "Obstacle", "Block", 'Bound', "Target" "Done", "Reward"]
        self.object_sizes = {"Action": 1, "Pusher": 2, "Obstacle": 2, "Block": 2, 'Bound': 2, "Target": 3, "Reward": 1, "Done": 1}
        self.object_name_dict = dict() # initialized in reset
        self.object_range = ranges
        self.object_dynamics = dynamics
        self.object_instanced = instanced
        self.position_masks = position_masks


        # reset counters
        self.reset()

    def generate_fill(self, class_type, idx, offset=0, max_adjacent=4):
        while True:
            pos = np.array([np.random.randint(0+offset, self.num_rows - offset), np.random.randint(0+offset, self.num_columns -offset)])
            if self.occupancy_matrix[pos[0]][pos[1]] is None:
                if max_adjacent < 4: # check adjacent cells for objects
                    total_adjacent = (int(pos[1] + 1 == self.num_columns or self.occupancy_matrix[pos[0]][pos[1]+1] is not None) + 
                        int(pos[1] - 1 == -1 or self.occupancy_matrix[pos[0]][pos[1]-1] is not None) +
                        int(pos[0] + 1 == self.num_rows or self.occupancy_matrix[pos[0] + 1][pos[1]] is not None) +
                        int(pos[0] - 1 == -1 or self.occupancy_matrix[pos[0]-1][pos[1]] is not None))
                    if total_adjacent > max_adjacent:
                        continue
                obj = class_type(pos, idx, self.bounds)
                self.occupancy_matrix[pos[0]][pos[1]] = obj
                # print(class_type, pos)
                break
        return obj

    def reset_occupancy(self): # resets the occupancy matrix assuming that the obstacles, blocks, and pusher and non-overlapping
        self.occupancy_matrix = [[None for i in range(self.num_columns)] for j in range(self.num_rows)]
        for obs in self.obstacles:
            self.occupancy_matrix[obs.pos[0]][obs.pos[1]] = obs
        for blk in self.blocks:
            self.occupancy_matrix[blk.pos[0]][blk.pos[1]] = blk
        for tar in self.targets:
            if self.occupancy_matrix[tar.pos[0]][tar.pos[1]] != None:
                self.occupancy_matrix[tar.pos[0]][tar.pos[1]] = ()
            self.occupancy_matrix[obs.pos[0]][obs.pos[1]] = obs

    def reset(self):
        if len(self.preset) > 0: # we are selecting resets from a preset group
            self.load_sokoban(self.preset)
        else: # load a random stage based on the inputs
            self.action = Action()
            self.bounds = [Bound(self.num_rows, 0), Bound(self.num_columns, 1)]
            self.occupancy_matrix = [[None for i in range(RNG)] for j in range(RNG)]
            self.pusher = Pusher(np.array([np.random.randint(self.num_rows), np.random.randint(self.num_columns)]), self.bounds)
            self.occupancy_matrix[self.pusher.pos[0]][self.pusher.pos[1]] = self.pusher
            self.obstacles = [self.generate_fill(Obstacle, i) for i in range(self.num_obstacles)]
            self.blocks = [self.generate_fill(Block, i, offset = 1, max_adjacent=1) for i in range(self.num_blocks)]
            self.targets = [self.generate_fill(Target, i, max_adjacent=3) for i in range(self.num_targets)]
            self.objects = [self.action] + [self.pusher] + self.obstacles + self.blocks + self.targets + self.bounds
        self.steps = 0
        return self.get_state()

    def clear_interactions(self):
        for obj in self.objects:
            obj.interaction_trace = list()

    def get_state(self, render=False):
        extracted_state = {**{obj.name: obj.get_state() for obj in self.objects}, **{"Done": self.done, "Reward": self.reward}}
        if render: self.frame = self.render()
        return {"raw_state": self.frame, "factored_state": extracted_state}

    def render(self, simple=False):
        self.frame = np.zeros((self.num_rows, self.num_columns))
        self.frame[tuple(self.pusher.pos.astype(int))] = .5
        for target in self.targets:
            self.frame[tuple(target.pos.astype(int))] = .4            
        if type(self.occupancy_matrix[int(self.pusher.pos[0])][int(self.pusher.pos[1])]) == tuple:
            self.frame[tuple(self.pusher.pos.astype(int))] = 0.6
        for obstacle in self.obstacles:
            self.frame[tuple(obstacle.pos.astype(int))] = .2
        for block in self.blocks:
            self.frame[tuple(block.pos.astype(int))] = .8
            if type(self.occupancy_matrix[int(block.pos[0])][int(block.pos[1])]) == tuple:
                self.frame[tuple(block.pos.astype(int))] = 1.0
        return self.frame

    def render_occupancy(self, simple=False):
        self.frame = np.zeros((self.num_rows, self.num_columns))
        for i in range(self.num_rows):
            for j in range(self.num_columns):
                obj = self.occupancy_matrix[i][j]
                # print(i,j,type(obj))
                if type(obj) == tuple and self.pusher.pos[0] == i and self.pusher.pos[1] == j:
                    self.frame[i][j] = 0.6
                if type(obj) == tuple and type(obj[0]) == Block:
                    self.frame[i][j] = 1.0
                if type(obj) == Pusher:
                    self.frame[i][j] = 0.5
                if type(obj) == Block:
                    self.frame[i][j] = 0.8
                if type(obj) == Target:
                    self.frame[i][j] = 0.4
                if type(obj) == Obstacle:
                    self.frame[i][j] = 0.2
        return self.frame


    def update_occupancy_matrix(self, old_pusher, old_block, new_block):
        old_pusher = old_pusher.astype(int)
        if new_block is not None: # move the block if necessary
            old_block =  old_block.astype(int)
            # print("old_block", old_block, new_block.pos, self.occupancy_matrix[old_block[0]][old_block[1]], self.occupancy_matrix[int(new_block.pos[0])][int(new_block.pos[1])])
            if type(self.occupancy_matrix[old_block[0]][old_block[1]]) == tuple:
                self.occupancy_matrix[old_block[0]][old_block[1]] = self.occupancy_matrix[old_block[0]][old_block[1]][1] # keep the target
            else:
                self.occupancy_matrix[old_block[0]][old_block[1]] = None
            obj_at_target = self.occupancy_matrix[int(new_block.pos[0])][int(new_block.pos[1])]
            if obj_at_target is not None: # object at location should be a target
                self.occupancy_matrix[int(new_block.pos[0])][int(new_block.pos[1])] = (new_block, obj_at_target)
            else:
                self.occupancy_matrix[int(new_block.pos[0])][int(new_block.pos[1])] = new_block
        
        # move the pusher if necessary
        # print("old push", old_pusher, self.occupancy_matrix[old_pusher[0]][old_pusher[1]], type(self.occupancy_matrix[old_pusher[0]][old_pusher[1]]), type(self.occupancy_matrix[old_pusher[0]][old_pusher[1]]) == tuple)
        if type(self.occupancy_matrix[old_pusher[0]][old_pusher[1]]) == tuple:
            self.occupancy_matrix[old_pusher[0]][old_pusher[1]] = self.occupancy_matrix[old_pusher[0]][old_pusher[1]][1] # keep the target
        else:
            self.occupancy_matrix[old_pusher[0]][old_pusher[1]] = None
        obj_at = self.occupancy_matrix[int(self.pusher.pos[0])][int(self.pusher.pos[1])]
        if type(obj_at) == Target:
            self.occupancy_matrix[int(self.pusher.pos[0])][int(self.pusher.pos[1])] = (self.pusher, obj_at)
        else: 
            self.occupancy_matrix[int(self.pusher.pos[0])][int(self.pusher.pos[1])] = self.pusher
        # print("update new pusher", self.pusher.pos, obj_at, self.occupancy_matrix[int(self.pusher.pos[0])][int(self.pusher.pos[1])])

    def check_targets(self):
        total = 0
        for target in self.targets:
            if target.attribute == 1:
                total += 1
        return total == len(self.targets)


    def step(self, action, render = False):
        self.reward = 0
        self.done = 0
        self.clear_interactions()
        for i in range(self.frameskip):
            self.action.step(action)
            self.pusher.step(self.action, self.occupancy_matrix)
            new_block, old_block = None, None
            for block in self.blocks:
                block.step(self.pusher, self.occupancy_matrix)
                old, moved = block.update()
                if moved is not None:
                    old_block = old
                    new_block = moved
            for target in self.targets:
                target.step(self.occupancy_matrix)
                target.update()
            old_push = self.pusher.update()
            self.update_occupancy_matrix(old_push, old_block, new_block)
            self.steps += 1
        self.itr += 1
        self.done = self.check_targets()
        self.reward = int(self.done) # get one reward if done
        self.done = self.done or self.steps == self.step_limit
        trunc = self.steps == self.step_limit
        state = self.get_state()
        print(self.steps, self.step_limit, self.done, self.reward)
        if self.done: self.reset()
        # print("end", self.occupancy_matrix[old_push[0]][old_push[1]])
        return state, self.reward, self.done, {"TimeLimit.truncated": trunc}

    def toString(self, extracted_state):
        estring = "ITR:" + str(self.itr) + "\t"
        for i, obj in enumerate(self.objects):
            estring += obj.name + ":" + " ".join(map(str, extracted_state[obj.name])) + "\t" # TODO: attributes are limited to single floats
        estring += "Reward:" + str(self.reward) + "\t"
        estring += "Done:" + str(int(self.done)) + "\t"
        return estring

    def set_from_factored_state(self, factored_state, seed_counter=-1, render=False):
        self.pusher.pos = factored_state["pusher"]

        for obstacle in self.obstacles:
            obstacle.pos = factored_state[obstacle.name]
        for block in self.blocks:
            block.pos = factored_state[block.name]
        for target in self.targets:
            target.pos = factored_state[target.name][:2]
            target.attribute = factored_state[target.name][2]

        self.reward = factored_state["Reward"]
        self.done = factored_state["Done"]

    def current_trace(self, names):
        targets = [self.object_name_dict[names.target]] if type(self.object_name_dict[names.target]) != list else self.object_name_dict[names.target]
        traces = list()
        for target in targets:
            if self.object_name_dict[names.primary_parent].name in target.interaction_trace:
                traces.append(1)
            else:
                traces.append(0)
        return traces

    def get_trace(self, factored_state, action, names):
        # gets the trace for a factored state, using the screen. If we don't want to screen to change, use a dummy screen here
        self.set_from_factored_state(factored_state)
        self.step(action)
        return self.current_trace(names)

    def demonstrate(self):
        action = 0
        frame = self.render()
        print(frame)
        frame = cv2.resize(frame, (frame.shape[0] * 30, frame.shape[1] * 30), interpolation = cv2.INTER_NEAREST)
        cv2.imshow('frame',frame)
        frame2 = self.render_occupancy()
        print(frame2)
        frame2 = cv2.resize(frame2, (frame2.shape[0] * 30, frame2.shape[1] * 30), interpolation = cv2.INTER_NEAREST)
        cv2.imshow('frame2',frame2)
        key = cv2.waitKey(5000)
        if key == ord('q'):
            action = -1
        elif key == ord('a'):
            action = 2
        elif key == ord('w'):
            action = 0
        elif key == ord('s'):
            action = 1
        elif key == ord('d'):
            action = 3
        return action


